/**
 *  Auteur: Pedrono Marie-Jo
 *
 * 	création : 13 février 2002
 *
 *  nature : projet etudiant
 *
 */


options{
	JDK_VERSION="1.5";	
}

PARSER_BEGIN(Yaka)



public class Yaka {

	public static String result = "" ;
	
	public static void main(String args[]) {
		Yaka analyseur;
		java.io.InputStream input;
		
		if (args.length==1) {
			System.out.print(args[args.length-1] + ": ");
			try {
				input = new java.io.FileInputStream(args[args.length-1]+".yaka");
			}
			catch (java.io.FileNotFoundException e) {
				System.out.println("Fichier introuvable.");
			return;
			}
		}
		else if (args.length==0) {
			System.out.println("Lecture sur l'entree standard...");
			input = System.in;
		}
		else {
			System.out.println("Usage: java Gram [fichier]");
			return;
		}
		try {
			analyseur = new Yaka(input);
			analyseur.analyse();
			System.out.println("analyse syntaxique reussie!");
			System.out.println(IdentArray.inString());
			System.out.println(Expression.inString()) ;
			System.out.println(result) ;
		}
		catch (ParseException e) {
			String msg = e.getMessage();
			System.out.println("Erreur de syntaxe : "+msg);
		}
	}

	
	/**
	 *  Lecture d'un programme
	 */
	public void prog() {
		  
	}
  
}

PARSER_END(Yaka)
/***************************************/
/********** TOKEN DEFINITIONS **********/
/***************************************/

TOKEN_MGR_DECLS :
{public static String identLu,chaineLue;
 public static int entierLu;}

/*** Skip whitespace and comments ***/
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "(*"   : IN_COMMENT
}
<IN_COMMENT> MORE:
{
  < ~[] >
}
<IN_COMMENT> SKIP:
{
   < "*)" >  {SwitchTo(DEFAULT);} 
}


/* Mots réservés*/

TOKEN :
{
	<PLUS : "+">
| 	<MOINS : "-">
|	<MUL : "*">
|	<DIV : "/">
|	<INF : "<">
|	<SUP : ">">
|	<INFEGAL : "<=">
|	<SUPEGAL : ">=">
|	<EGAL : "=">
|	<DIFF : "<>">
| 	<ET : "ET">
|	<OU : "OU">
| 	<NON : "NON">
|	<ERROR : "error">
|  < BOOLEEN: "BOOLEEN" >
| < VAR: "VAR" >
| < FAIRE: "FAIRE" >
| < SINON: "SINON" >
| < POUR: "POUR" >
| < SI: "SI" >
| < FSI: "FSI">
| < ENTIER: "ENTIER" >
| < RETOURNE: "RETOURNE" >
| < VRAI: "VRAI" >
| < TANTQUE: "TANTQUE" >
| <CONST : "CONST">
| <FAUX : "FAUX">
| <FAIT : "FAIT">
| <FONCTION : "FONCTION">
| <FFONCTION  : "FFONCTION">
| <PROGRAMME : "PROGRAMME" >
| <FPROGRAMME: "FPROGRAMME" >
| <PRINCIPAL : "PRINCIPAL">
| <FPRINCIPAL : "FPRINCIPAL">
| <ALORS : "ALORS">
| <ECRIRE : "ECRIRE">
| <LIRE : "LIRE">
| <ALALIGNE : "ALALIGNE">

}



/*** unites de base nombres, idents,  strings ***/
TOKEN  :
{
  < #chiffre : ["0"-"9"] >
| < entier : (<chiffre>)+ > 
	{entierLu = Integer.parseInt(image.toString());}
| < #lettre: ["A"-"Z","a"-"z"] >
| < ident : <lettre> (<lettre> | <chiffre>)* >
	{identLu = image.toString();}
| < chaine : "\"" (~["\""])* "\"" | "'" (~["'"])* "'" >
	{chaineLue = image.toString();}
}


/**************************************/
/********debut de la grammaire ********/
/**************************************/
void analyse() : {}
{
   <PROGRAMME> <ident>{Yaka.result += "entete" ;}	
   bloc()
   <FPROGRAMME>{Yaka.result += "\nqueue" ;} 
}

void bloc() : {}{
 (declConst())*
 (declVar())*{Yaka.result += "\nouvrePrinc "+ IdentArray.nbVar() ;}	
   suiteExpr() 
}

void declConst() : {}
{
  <CONST>  defConst() ( "," defConst())* ";"
}

void defConst() : {}
{
	
  (
		  (<ident>) {IdentArray.lastIdent = YakaTokenManager.identLu;}
		  "=" valConst()
  ) {IdentArray.add(IdentArray.lastIdent, new IdConst(IdentArray.lastValue, IdentArray.lastType));}
}

void valConst() : {}{
  (<entier>) {
	  IdentArray.lastValue = YakaTokenManager.entierLu;
	  IdentArray.lastType = YakaConstants.tokenImage[ENTIER];
 }
  
 | (<ident>) {
	 IdConst i = (IdConst) IdentArray.get(YakaTokenManager.identLu);
	 if(i != null) {
		 IdentArray.lastValue = i.value;
		 IdentArray.lastType = i.type;
	 }
	 else {
		 TokenMgrError error = new TokenMgrError("Error : "+YakaTokenManager.identLu+" ident not found", TokenMgrError.LEXICAL_ERROR);
		 System.err.println(error.getMessage());
	 }
 }
 
 | (<VRAI>) {
	 IdentArray.lastValue = Ident.TRUE;
	 IdentArray.lastType = YakaConstants.tokenImage[BOOLEEN];
 }
 
 | (<FAUX>) {
	 IdentArray.lastValue = Ident.FALSE;
	 IdentArray.lastType = YakaConstants.tokenImage[BOOLEEN];
 }
 
}


void declVar() : {}
{
  <VAR> type()
  (<ident>) {
	  IdentArray.shiftOffset();
	  IdentArray.add(YakaTokenManager.identLu, new IdVar(IdentArray.currentOffset, IdentArray.lastType));
  }
  ("," 
      (<ident>) {
		  IdentArray.shiftOffset();
		  IdentArray.add(YakaTokenManager.identLu, new IdVar(IdentArray.currentOffset, IdentArray.lastType));
	  }
  )* ";"
	
}

void type() :{}
{
   (<ENTIER>) {IdentArray.lastType = YakaConstants.tokenImage[ENTIER];}			
 | (<BOOLEEN>) {IdentArray.lastType = YakaConstants.tokenImage[BOOLEEN];}		
}
/*
 * Syntaxe des instructions.
 */
void suiteExpr() : {}
{ (expression() (";" (expression())? )*)? }



/*
 * Expression .
 */
void expression() : {}
{
  simpleExpr() 
  (opRel() 
  simpleExpr() 			{
  	  			String t1 = Expression.popType() ;
  	  			String t2 = Expression.popType() ;
  	  			String op = Expression.popOperator() ;  			
  	  		  	  			
  	  			String res = Expression.binExprReturn(t1,t2,op) ;
  	  			Expression.addType(res) ;
  	  			
  	  			String inf =  YakaConstants.tokenImage[INF] ;							
				String infegal = YakaConstants.tokenImage[INFEGAL] ;								
				String sup = YakaConstants.tokenImage[SUP] ;								
				String supegal = YakaConstants.tokenImage[SUPEGAL] ;
				String egal = YakaConstants.tokenImage[EGAL] ;								
				String diff = YakaConstants.tokenImage[DIFF] ;	  		
				
				try {
					if (res==YakaConstants.tokenImage[ERROR])
						throw new ParseException("type err");
					else {
						String s = "" ;
						if (op==inf)		s = "\niinf " ;							
						if (op==infegal)	s = "\niinfegal " ;								
						if (op==sup)		s = "\nisup " ;								
						if (op==supegal)	s = "\nisupegal " ;						
						if (op==egal)		s = "\niegal " ;								
						if (op==diff)		s = "\nidiff " ;
						
						if (s=="")
							throw new ParseException("operator err");
						else
							Yaka.result += s ;						
					}
				}
				catch (ParseException e) {
					String msg = e.getMessage();
					System.out.println("Erreur de syntaxe : "+msg);
				}				
  				}
  )?
}
                
                
void simpleExpr() : {}
{
   terme() 
   (opAdd() 
   terme()			{
  	  			String t1 = Expression.popType() ;
  	  			String t2 = Expression.popType() ;
  	  			String op = Expression.popOperator() ;
    	  			
  	  			String res = Expression.binExprReturn(t1,t2,op) ;
  	  			Expression.addType(res) ;
  	  			
				String plus = YakaConstants.tokenImage[PLUS] ;
				String moins = YakaConstants.tokenImage[MOINS] ;							
				String ou = YakaConstants.tokenImage[OU] ;  
				
  	  			try {
					if (res==YakaConstants.tokenImage[ERROR])
						throw new ParseException("type err");
					else {
						String s = "" ;
						if (op==plus)		s = "\niadd " ;							
						if (op==moins)		s = "\nisub " ;							
						if (op==ou)		s = "\nior " ;
						
						if (s=="")
							throw new ParseException("operator err");
						else
							Yaka.result += s ;						
					}
				}
				catch (ParseException e) {
					String msg = e.getMessage();
					System.out.println("Erreur de syntaxe : "+msg);
				}				
  				}	
   )*
} 
void terme() : {}
{
  facteur() 
  (opMul() 
  facteur()			{
  	  			String t1 = Expression.popType() ;
  	  			String t2 = Expression.popType() ;
  	  			String op = Expression.popOperator() ;
  	  			    	  			
  	  			String res = Expression.binExprReturn(t1,t2,op) ;
  	  			Expression.addType(res) ;
  	  			
				String mul = YakaConstants.tokenImage[MUL] ;
				String div = YakaConstants.tokenImage[DIV] ;
				String et = YakaConstants.tokenImage[ET] ;
  	  			
  	  			try {
					if (res==YakaConstants.tokenImage[ERROR])
						throw new ParseException("type err");
					else {
						String s = "" ;
						if (op==mul)		s = "\nimul " ;							
						if (op==div)		s = "\nidiv " ;
						if (op==et)		s = "\niand " ;
			
						if (s=="")
							throw new ParseException("operator err");
						else
							Yaka.result += s ;						
					}
				}
				catch (ParseException e) {
					String msg = e.getMessage();
					System.out.println("Erreur de syntaxe : "+msg);
				}				
  				}
  )*
}
void facteur() : {}
{   primaire() 
  |  opNeg() primaire() 	{
  	  			String t = Expression.popType() ;
  	  			String op = Expression.popOperator() ;
  	  			
  	  			String res = Expression.unExprReturn(t,op) ;
  	  			Expression.addType(res) ;
  	  			
  	  			try {
					if (res==YakaConstants.tokenImage[ERROR])
						throw new ParseException("type err");
					else {
						String s = "" ; 
						if (op==YakaConstants.tokenImage[MOINS])	s = "\nineg " ;							
						if (op==YakaConstants.tokenImage[NON])		s = "\ninot " ;
						
						if (s=="")
							throw new ParseException("operator err");
						else
							Yaka.result += s ;						
					}
				}
				catch (ParseException e) {
					String msg = e.getMessage();
					System.out.println("Erreur de syntaxe : "+msg);
				}				
  				}
}

void primaire (): {}
{
   valeur()
 | "(" expression() ")" 
 
}

void valeur () : {}
{ <entier>	{
		Expression.addType("\"ENTIER\"");
		Yaka.result += "\niconst " + YakaTokenManager.entierLu ;
		}
 | <ident> 	{
 	 	Expression.addType(IdentArray.get(YakaTokenManager.identLu).type);
 		if (IdentArray.get(YakaTokenManager.identLu).isVar())
 			Yaka.result += "\niload " ;
 		else
 			Yaka.result += "\niconst " ;
 		Yaka.result += IdentArray.get(YakaTokenManager.identLu).getValue() ;
 		}
 | <VRAI> 	{
 	 	Expression.addType("\"BOOLEEN\"");
 		Yaka.result += "\niconst " + Ident.TRUE ;
 		}	
 | <FAUX> 	{
 	 	Expression.addType("\"BOOLEEN\"");
 		Yaka.result += "\niconst " + Ident.FALSE ;
 		}
 
}

void opRel() : {}
{
   <EGAL> 	{Expression.addOperator(YakaConstants.tokenImage[EGAL]) ;}		
 | <DIFF> 	{Expression.addOperator(YakaConstants.tokenImage[DIFF]) ;}	
 | <INF>	{Expression.addOperator(YakaConstants.tokenImage[INF]) ;}		
 | <INFEGAL>	{Expression.addOperator(YakaConstants.tokenImage[INFEGAL]) ;}	
 | <SUP> 	{Expression.addOperator(YakaConstants.tokenImage[SUP]) ;}	
 | <SUPEGAL>	{Expression.addOperator(YakaConstants.tokenImage[SUPEGAL]) ;}	
} 

void opAdd() : {}
{
    <PLUS>	{Expression.addOperator(YakaConstants.tokenImage[PLUS]) ;}	
  |  <MOINS>  	{Expression.addOperator(YakaConstants.tokenImage[MOINS]) ;}	
  | <OU> 	{Expression.addOperator(YakaConstants.tokenImage[OU]) ;}	
}

void opMul() : {}
{
  <MUL>		{Expression.addOperator(YakaConstants.tokenImage[MUL]) ;}	
  | <DIV>	{Expression.addOperator(YakaConstants.tokenImage[DIV]) ;}	
  | <ET>	{Expression.addOperator(YakaConstants.tokenImage[ET]) ;}		
} 

void opNeg() : {}
{ <MOINS>	{Expression.addOperator(YakaConstants.tokenImage[MOINS]) ;}		
 | <NON>	{Expression.addOperator(YakaConstants.tokenImage[NON]) ;}	
}


