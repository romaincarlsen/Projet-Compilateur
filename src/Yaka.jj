/**
 *  Auteur: Pedrono Marie-Jo
 *
 * 	creation : 13 fevrier 2002
 *
 *  Nature : Projet Etudiant
 *
 */

options {
	JDK_VERSION = "1.7";
}

PARSER_BEGIN(Yaka)

	public class Yaka {

		// Choix de l'interpreteur a utiliser
		public static String interpreterType = "YVMasm"; // YVM ou YVMasm

		// Nom du fichier a creer par l'interpreteur
		public static String scriptOutputName = "../outputs/{{FILENAME}}.asm";

		// Interpreteur
		public static YVM Interpreter;

		// Pour se souvenir s'il y a déjà eu une erreur
		public static boolean err = false;


		// Main : point d'entree pour le compilateur
		public static void main(String args[]) {

			Yaka analyzer;
			java.io.InputStream input;

			Writer.print("\n"); // Juste pour un affichage plus claire

			// Recuperation du texte/script a traiter
			if(args.length==1) {
				try {
					String pathToFile = args[args.length-1];
					String[] explodePath = pathToFile.split("/");

					// Le nom du fichier de sortie est le même avec l'extension ".asm" dans le dossier "outputs"
					scriptOutputName = scriptOutputName.replace("{{FILENAME}}", explodePath[explodePath.length - 1]);

					// On récupère le contenu du fichier
					input = new java.io.FileInputStream(pathToFile+".yaka");
				}
				catch (java.io.FileNotFoundException e) {
					err = true;
					Writer.errorln("Fichier introuvable !\n");
					return;
				}
			}
			else if (args.length == 0) {
				Writer.println("Lecture sur l'entree standard...\n");

				// Le nom du fichier de sortie est "test.asm" dans le dossier "outputs"
				scriptOutputName = scriptOutputName.replace("{{FILENAME}}", "out");

				// On récupère le contenu de la console
				input = System.in;
			}
			else {
				Writer.errorln("Usage: java Gram [fichier]\n");
				return;
			}

			// Declaration de l'interpreteur
			if(interpreterType.equals("YVM")) {
				Interpreter = new YVM(scriptOutputName);
			}
			else if(interpreterType.equals("YVMasm")) {
				Interpreter = new YVMasm(scriptOutputName);
			}

			// Analyse
			try {

				analyzer = new Yaka(input);
				analyzer.analyse();

				if(!err) {

					Writer.println("Analyse Syntaxique terminee !\n");

					// On affiche le resultat du tableau d'ident
					//Writer.println(IdentArray.string());

					// On affiche le resultat du tableau d'expression
					//Writer.println(Expression.string()) ;

					// On créer le script YVM
					Interpreter.outputSave();

					Writer.println("Programme de sortie : "+scriptOutputName+"\n");
				}

			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}


		/**
		 *  Lecture d'un programme
		 */
		public void prog() {

		}

	}

PARSER_END(Yaka)



/***************************************/
/********** TOKEN DEFINITIONS **********/
/***************************************/

TOKEN_MGR_DECLS : {
	public static String identLu, chaineLue;
	public static int entierLu;
	public static int currentLine = 1;
}


/*** Skip whitespace and comments ***/
SKIP : {
	  " "
	| "\t"
	| "\n" {YakaTokenManager.currentLine++;}
	| "\r"
	| "(*" : IN_COMMENT
}

<IN_COMMENT> MORE: {
	< ~[] >
}

<IN_COMMENT> SKIP: {
	< "*)" > {SwitchTo(DEFAULT);}
}


/*** Mots reserves ***/
TOKEN : {
	  <PLUS : "+">
	| <MOINS : "-">
	| <MUL : "*">
	| <DIV : "/">
	| <INF : "<">
	| <SUP : ">">
	| <INFEGAL : "<=">
	| <SUPEGAL : ">=">
	| <EGAL : "=">
	| <DIFF : "<>">
	| <ET : "ET">
	| <OU : "OU">
	| <NON : "NON">
	| <ERROR : "error">
	| < BOOLEEN: "BOOLEEN" >
	| < VAR: "VAR" >
	| < FAIRE: "FAIRE" >
	| < SINON: "SINON" >
	| < POUR: "POUR" >
	| < SI: "SI" >
	| < FSI: "FSI">
	| < ENTIER: "ENTIER" >
	| < RETOURNE: "RETOURNE" >
	| < VRAI: "VRAI" >
	| < TANTQUE: "TANTQUE" >
	| <CONST : "CONST">
	| <FAUX : "FAUX">
	| <FAIT : "FAIT">
	| <FONCTION : "FONCTION">
	| <FFONCTION  : "FFONCTION">
	| <PROGRAMME : "PROGRAMME" >
	| <FPROGRAMME: "FPROGRAMME" >
	| <PRINCIPAL : "PRINCIPAL">
	| <FPRINCIPAL : "FPRINCIPAL">
	| <ALORS : "ALORS">
	| <ECRIRE : "ECRIRE">
	| <LIRE : "LIRE">
	| <ALALIGNE : "ALALIGNE">
}


/*** unites de base nombres, idents,  strings ***/
TOKEN  : {
	  < #chiffre : ["0"-"9"] >

	| < #lettre: ["A"-"Z","a"-"z"] >

	| < entier : (<chiffre>)+ > {
		entierLu = Integer.parseInt(image.toString());
	}

	| < ident : <lettre> (<lettre> | <chiffre>)* > {
		identLu = image.toString();
	}

	| < chaine : "\"" (~["\""])* "\"" | "'" (~["'"])* "'" > {
		chaineLue = image.toString();
	}
}



/**************************************/
/********debut de la grammaire ********/
/**************************************/

void analyse() : {} {
	<PROGRAMME> <ident>{
		Yaka.Interpreter.entete();
	}
	bloc()
	<FPROGRAMME>{
		Yaka.Interpreter.queue();
	}
}


void bloc() : {} {
	(declConst())*
	(declVar())* {
		Yaka.Interpreter.ouvrePrinc(IdentArray.nbVar());
	}
	suiteInstr()
}


void declConst() : {} {
	<CONST>
	defConst()
	( "," defConst() )*
	";"
}


void defConst() : {} {
	(
		(<ident>) {
			IdentArray.lastIdent = YakaTokenManager.identLu;
		}

		"=" valConst()
	) {
		IdentArray.add(IdentArray.lastIdent, new IdConst(IdentArray.lastValue, IdentArray.lastType));
	}
}


void valConst() : {} {
	(<entier>) {
		IdentArray.lastValue = YakaTokenManager.entierLu;
		IdentArray.lastType = tokenImage[ENTIER];
	}

	| (<ident>) {
		try {
			IdConst id = (IdConst) IdentArray.get(YakaTokenManager.identLu);

			if(id == null)
				throw new ParseException("Identifiant \""+YakaTokenManager.identLu+"\" non declare");

			IdentArray.lastValue = id.value;
			IdentArray.lastType = id.type;
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur lexicale, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}

 	}

	| (<VRAI>) {
		IdentArray.lastValue = Yaka.Interpreter.TRUE;
		IdentArray.lastType = tokenImage[BOOLEEN];
	}

	| (<FAUX>) {
		IdentArray.lastValue = Yaka.Interpreter.FALSE;
		IdentArray.lastType = tokenImage[BOOLEEN];
	}

}


void declVar() : {} {
	<VAR> type()
	(<ident>) {
		IdentArray.shiftOffset();
		IdentArray.add(
			YakaTokenManager.identLu,
			new IdVar(IdentArray.currentOffset, IdentArray.lastType)
		);
	}
	(
		","
		(<ident>) {
			IdentArray.shiftOffset();
			IdentArray.add(
				YakaTokenManager.identLu,
				new IdVar(IdentArray.currentOffset, IdentArray.lastType)
			);
		}
	)*
	";"
}


void type() :{} {
	(<ENTIER>) {
	  	IdentArray.lastType = tokenImage[ENTIER];
	}

	| (<BOOLEEN>) {
		IdentArray.lastType = tokenImage[BOOLEEN];
	}
}


/**
 * Syntaxe des instructions
 */
void suiteInstr() : {} {
	instruction()
	( ";" (instruction())? )*
}

void boucle() : {} {
					{
						// placer l'étiquette de début
						Yaka.Interpreter.label(Iteration.genereEtiquetteDebut()) ;
						
					}
	<TANTQUE> expression() <FAIRE> {
						try {// vérifier que type booléen et écrire le ligne de test
							String expr = Expression.popType();
							if (expr != YakaConstants.tokenImage[YakaConstants.BOOLEEN])
								throw new ParseException("type expression attendue après TANTQUE : BOOLEEN, type expression relevée "+ expr);
							Yaka.Interpreter.iffaux(Iteration.etiquetteCouranteFin()) ;
						}
						catch(ParseException e) {
							err = true;
							TokenMgrError error = new TokenMgrError(
								"Erreur d'étiquette, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
								TokenMgrError.LEXICAL_ERROR
							);
							Writer.errorln(error.getMessage());
						}
					}
		
		(suiteInstr())*
					{
						// placer le goto vers l'étiquette de début	
						Yaka.Interpreter.jump(Iteration.etiquetteCouranteDebut()) ;
						
					}
	<FAIT>				{
						// placer l'étiquette de fin
						Yaka.Interpreter.label(Iteration.genereEtiquetteFin()) ;
					}
}

void instruction() : {} {
	affectation() |
	lecture()|
	ecriture() |
	boucle()
}


void affectation() : {} {
	(<ident>) {
		Ident affectId = IdentArray.get(YakaTokenManager.identLu);
		try {
			if(affectId.isConst())
				throw new ParseException("Affectation impossible sur une constante");
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur d'affectation, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}

	}
	(<EGAL> expression()) {
		Yaka.Interpreter.affect(affectId);
	}
}


void lecture() : {} {
	(<LIRE>"("<ident>")") {
		Yaka.Interpreter.lireEnt(IdentArray.get(YakaTokenManager.identLu));
	}
}


void ecriture() : {} {

	(<ECRIRE>"("

		(expression() {
			// Todo
			Yaka.Interpreter.ecrireEnt();
		}
		| <chaine> {
			Yaka.Interpreter.ecrireChaine(YakaTokenManager.chaineLue);
		})

	")")

	| (<ALALIGNE>) {
		Yaka.Interpreter.aLaLigne();
	}
}


/**
 * Expression
 */
void expression() : {} {

	simpleExpr()

	(
		opRel()
		simpleExpr() {

			String t1 = Expression.popType();
			String t2 = Expression.popType();
			String op = Expression.popOperator();

			String inf =  tokenImage[INF];
			String infegal = tokenImage[INFEGAL];
			String sup = tokenImage[SUP];
			String supegal = tokenImage[SUPEGAL];
			String egal = tokenImage[EGAL];
			String diff = tokenImage[DIFF];

			try {

				String res = Expression.binExprReturn(t1,t2,op);

				if(res == tokenImage[ERROR] && t1 != tokenImage[ERROR] && t2 != tokenImage[ERROR])
					throw new ParseException("Operation de type "+t1+" "+op+" "+t2+" interdite");

				else {
					Expression.addType(res);

					if (op == inf)
						Yaka.Interpreter.iinf();

					else if (op == infegal)
						Yaka.Interpreter.iinfegal();

					else if (op == sup)
						Yaka.Interpreter.isup();

					else if (op == supegal)
						Yaka.Interpreter.isupegal();

					else if (op == egal)
						Yaka.Interpreter.iegal();

					else if (op == diff)
						Yaka.Interpreter.idiff();

					else
						throw new ParseException("Operateur "+op+" inattendu");
				}
			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}
	)?

}


void simpleExpr() : {} {

	terme()
	(
		opAdd()
		terme() {

			String t1 = Expression.popType();
			String t2 = Expression.popType();
			String op = Expression.popOperator();

			String plus = tokenImage[PLUS];
			String moins = tokenImage[MOINS];
			String ou = tokenImage[OU];

			try {

				String res = Expression.binExprReturn(t1,t2,op);

				if(res == tokenImage[ERROR]&& t1 != tokenImage[ERROR] && t2 != tokenImage[ERROR])
					throw new ParseException("Operation de type "+t1+" "+op+" "+t2+" interdite");

				else {
					Expression.addType(res);

					if(op == plus)
						Yaka.Interpreter.iadd();

					else if (op == moins)
						Yaka.Interpreter.isub();

					else if (op == ou)
						Yaka.Interpreter.ior();

					else
						throw new ParseException("Operateur "+op+" innatendu");
				}
			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}
	)*

}


void terme() : {} {

	facteur()
	(
		opMul()
		facteur() {

			String t1 = Expression.popType();
			String t2 = Expression.popType();
			String op = Expression.popOperator();

			String mul = tokenImage[MUL];
			String div = tokenImage[DIV];
			String et = tokenImage[ET];

			try {

				String res = Expression.binExprReturn(t1,t2,op);

				if(res == tokenImage[ERROR] && t1 != tokenImage[ERROR] && t2 != tokenImage[ERROR])
					throw new ParseException("Operation de type "+t1+" "+op+" "+t2+" interdite");

				else {
					Expression.addType(res);

					if (op == mul)
						Yaka.Interpreter.imul();

					else if (op == div)
						Yaka.Interpreter.idiv();

					else if(op == et)
						Yaka.Interpreter.iand();

					else
						throw new ParseException("Operateur "+op+" innatendu");
				}
			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}
	)*

}

void facteur() : {} {

	primaire()
	| opNeg() primaire() {

		String t = Expression.popType();
		String op = Expression.popOperator();

		try {

			String res = Expression.unExprReturn(t, op);

			if(res == tokenImage[ERROR] && t != tokenImage[ERROR])
					throw new ParseException("Operation de type "+op+" "+t+" interdite");

			else {
				Expression.addType(res);

				if(op == tokenImage[MOINS])
					Yaka.Interpreter.ineg();

				else if(op == tokenImage[NON])
					Yaka.Interpreter.inot();

				else
					throw new ParseException("Operateur "+op+" innatendu");
			}
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}
	}
}


void primaire (): {} {
	valeur()
	| "(" expression() ")"
}


void valeur () : {} {
	(<entier> {
		Expression.addType(tokenImage[ENTIER]);
		Yaka.Interpreter.iconst(YakaTokenManager.entierLu);
	}

	| <ident> {
		try {
			Ident id = IdentArray.get(YakaTokenManager.identLu);

			if(id == null){
				Expression.addType(YakaConstants.tokenImage[YakaConstants.ERROR]);
				throw new ParseException("Identifiant \""+YakaTokenManager.identLu+"\" non declare");
			}

			Expression.addType(IdentArray.get(YakaTokenManager.identLu).type);

			if(id.isVar())
				Yaka.Interpreter.iload(id.getValue());

			else if(id.isConst())
				Yaka.Interpreter.iconst(id.getValue());
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur lexicale, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}
	}

	| <VRAI> 	{
		Expression.addType(tokenImage[BOOLEEN]);
		Yaka.Interpreter.iconst(Yaka.Interpreter.TRUE);
	}

	| <FAUX> 	{
		Expression.addType(tokenImage[BOOLEEN]);
		Yaka.Interpreter.iconst(Yaka.Interpreter.FALSE);
	})

}


void opRel() : {} {
	<EGAL> {
		Expression.addOperator(tokenImage[EGAL]);
	}

	| <DIFF> {
		Expression.addOperator(tokenImage[DIFF]);
	}

	| <INF>	{
		Expression.addOperator(tokenImage[INF]);
	}

	| <INFEGAL>	{
		Expression.addOperator(tokenImage[INFEGAL]);
	}

	| <SUP> {
		Expression.addOperator(tokenImage[SUP]);
	}

	| <SUPEGAL>	{
		Expression.addOperator(tokenImage[SUPEGAL]);
	}
}


void opAdd() : {} {
	<PLUS> {
		Expression.addOperator(tokenImage[PLUS]);
	}

	| <MOINS> {
		Expression.addOperator(tokenImage[MOINS]);
	}

	| <OU> {
		Expression.addOperator(tokenImage[OU]);
	}
}


void opMul() : {} {
	<MUL> {
		Expression.addOperator(tokenImage[MUL]);
	}

	| <DIV> {
		Expression.addOperator(tokenImage[DIV]);
	}

	| <ET> {
		Expression.addOperator(tokenImage[ET]);
	}
}


void opNeg() : {} {
	<MOINS> {
		Expression.addOperator(tokenImage[MOINS]);
	}

	| <NON> {
		Expression.addOperator(tokenImage[NON]);
	}
}


