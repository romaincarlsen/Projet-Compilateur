/**
 *  Auteur: Pedrono Marie-Jo
 *
 * 	creation : 13 fevrier 2002
 *
 *  Nature : Projet Etudiant
 *
 */

options {
	JDK_VERSION = "1.7";
}

PARSER_BEGIN(Yaka)

	public class Yaka {

		// Choix de l'interpreteur a utiliser
		public static String interpreterType = "YVMasm"; // YVM ou YVMasm

		// Nom du fichier a creer par l'interpreteur
		public static String scriptOutputName = "../outputs/{{FILENAME}}.asm";

		// Interpreteur
		public static YVM Interpreter;

		// Pour se souvenir s'il y a déjà eu une erreur
		public static boolean err = false;


		// Main : point d'entree pour le compilateur
		public static void main(String args[]) {

			Yaka analyzer;
			java.io.InputStream input;

			Writer.print("\n"); // Juste pour un affichage plus claire

			// Recuperation du texte/script a traiter
			if(args.length==1) {
				try {
					String pathToFile = args[args.length-1];
					String[] explodePath = pathToFile.split("/");
					
					// Le nom du fichier de sortie est le même avec l'extension ".asm" dans le dossier "outputs"
					scriptOutputName = scriptOutputName.replace("{{FILENAME}}", explodePath[explodePath.length - 1]);

					// On récupère le contenu du fichier
					input = new java.io.FileInputStream(pathToFile+".yaka");
				}
				catch (java.io.FileNotFoundException e) {
					err = true;
					Writer.errorln("Fichier introuvable !\n");
					return;
				}
			}
			else if (args.length == 0) {
				Writer.println("Lecture sur l'entree standard...\n");

				// Le nom du fichier de sortie est "test.asm" dans le dossier "outputs"
				scriptOutputName = scriptOutputName.replace("{{FILENAME}}", "out");

				// On récupère le contenu de la console
				input = System.in;
			}
			else {
				Writer.errorln("Usage: java Gram [fichier]\n");
				return;
			}

			// Declaration de l'interpreteur
			if(interpreterType.equals("YVM")) {
				Interpreter = new YVM(scriptOutputName);
			}
			else if(interpreterType.equals("YVMasm")) {
				Interpreter = new YVMasm(scriptOutputName);
			}

			// Analyse
			try {

				analyzer = new Yaka(input);
				analyzer.analyse();

				System.out.println(IdentArray.string()) ;
				
				if(!err) {

					Writer.println("Analyse Syntaxique terminee !\n");

					// On affiche le resultat du tableau d'ident
					//Writer.println(IdentArray.string());

					// On affiche le resultat du tableau d'expression
					//Writer.println(Expression.string()) ;

					// On créer le script YVM
					Interpreter.outputSave();

					
					Writer.println("Programme de sortie : "+scriptOutputName+"\n");
					
				}

			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}

	}

PARSER_END(Yaka)



/***************************************/
/********** TOKEN DEFINITIONS **********/
/***************************************/

TOKEN_MGR_DECLS : {
	public static String identLu, chaineLue;
	public static int entierLu;
	public static int currentLine = 1;
}


/*** Skip whitespace and comments ***/
SKIP : {
	  " "
	| "\t"
	| "\n" {YakaTokenManager.currentLine++;}
	| "\r"
	| "(*" : IN_COMMENT
}

<IN_COMMENT> MORE: {
	< ~[] >
}

<IN_COMMENT> SKIP: {
	< "*)" > {SwitchTo(DEFAULT);}
}


/*** Mots reserves ***/
TOKEN : {
	  <PLUS : "+">
	| <MOINS : "-">
	| <MUL : "*">
	| <DIV : "/">
	| <INF : "<">
	| <SUP : ">">
	| <INFEGAL : "<=">
	| <SUPEGAL : ">=">
	| <EGAL : "=">
	| <DIFF : "<>">
	| <ET : "ET">
	| <OU : "OU">
	| <NON : "NON">
	| <ERROR : "error">
	| < BOOLEEN: "BOOLEEN" >
	| < VAR: "VAR" >
	| < FAIRE: "FAIRE" >
	| < SINON: "SINON" >
	| < POUR: "POUR" >
	| < SI: "SI" >
	| < FSI: "FSI">
	| < ENTIER: "ENTIER" >
	| < RETOURNE: "RETOURNE" >
	| < VRAI: "VRAI" >
	| < TANTQUE: "TANTQUE" >
	| <CONST : "CONST">
	| <FAUX : "FAUX">
	| <FAIT : "FAIT">
	| <FONCTION : "FONCTION">
	| <FFONCTION  : "FFONCTION">
	| <PROGRAMME : "PROGRAMME" >
	| <FPROGRAMME: "FPROGRAMME" >
	| <PRINCIPAL : "PRINCIPAL">
	| <FPRINCIPAL : "FPRINCIPAL">
	| <ALORS : "ALORS">
	| <ECRIRE : "ECRIRE">
	| <LIRE : "LIRE">
	| <ALALIGNE : "ALALIGNE">
}


/*** unites de base nombres, idents,  strings ***/
TOKEN  : {
	  < #chiffre : ["0"-"9"] >

	| < #lettre: ["A"-"Z","a"-"z"] >

	| < entier : (<chiffre>)+ > {
		entierLu = Integer.parseInt(image.toString());
	}

	| < ident : <lettre> (<lettre> | <chiffre>)* > {
		identLu = image.toString();
	}

	| < chaine : "\"" (~["\""])* "\"" | "'" (~["'"])* "'" > {
		chaineLue = image.toString();
	}
}







/**
 * ===============================================================
 * =================== *** __ Grammaire __ *** ===================
 * ===============================================================
 */

void analyse() : {} {
	<PROGRAMME> {
		Yaka.Interpreter.entete();
	}
	<ident>
	(declFonction())*
	<PRINCIPAL>	{
				Yaka.Interpreter.label("main") ;		
			}
	bloc()
	<FPRINCIPAL>
	<FPROGRAMME> {
		Yaka.Interpreter.queue();
	}
}


void bloc() : {} {
	(declConst())*
	(declVar())* {
			Yaka.Interpreter.ouvrebloc(IdentArray.nbVar());
			}
	suiteInstr() {
			Yaka.Interpreter.fermebloc(IdentArray.nbParams());
			}
}


void type() : {} {
	(<ENTIER>) {
	  	IdentArray.lastType = tokenImage[ENTIER];
	}

	| (<BOOLEEN>) {
		IdentArray.lastType = tokenImage[BOOLEEN];
	}
}






/**
 * ====================================================
 * =================== Déclarations ===================
 * ====================================================
 */

// CONST type constante, constante, ... ;
void declConst() : {} {
	<CONST>
	defConst()
	( "," defConst() )*
	";"
}


void defConst() : {} {
	(
		(<ident>) {
			IdentArray.lastIdent = YakaTokenManager.identLu;
		}

		<EGAL> valConst()
	) {
		IdentArray.addLocal(IdentArray.lastIdent, new IdConst(IdentArray.lastValue, IdentArray.lastType));
	}
}


void valConst() : {} {
	(<entier>) {
		IdentArray.lastValue = YakaTokenManager.entierLu;
		IdentArray.lastType = tokenImage[ENTIER];
	}

	| (<ident>) {
		try {
			IdConst id = (IdConst) IdentArray.getLocal(YakaTokenManager.identLu);

			if(id == null)
				throw new ParseException("Identifiant \""+YakaTokenManager.identLu+"\" non declare");

			IdentArray.lastValue = id.value;
			IdentArray.lastType = id.type;
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur lexicale, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}

 	}

	| (<VRAI>) {
		IdentArray.lastValue = Yaka.Interpreter.TRUE;
		IdentArray.lastType = tokenImage[BOOLEEN];
	}

	| (<FAUX>) {
		IdentArray.lastValue = Yaka.Interpreter.FALSE;
		IdentArray.lastType = tokenImage[BOOLEEN];
	}

}


// VAR type variable, variable, ... ;
void declVar() : {} {
	<VAR> type()
	(<ident>) {
		IdentArray.shiftOffsetVar();
		IdentArray.addLocal(
			YakaTokenManager.identLu,
			new IdVar(IdentArray.offsetVar, IdentArray.lastType)
		);
	}
	(
		","
		(<ident>) {
			IdentArray.shiftOffsetVar();
			IdentArray.addLocal(
				YakaTokenManager.identLu,
				new IdVar(IdentArray.offsetVar, IdentArray.lastType)
			);
		}
	)*
	";"
}


// type FONCTION fonction(type variable, type variable, ...)
//     instructions
//     RETOURNE (variable | expression)
// FFONCTION
void declFonction() : {} {
	// Todo : vérifier que la valeur de retour correspondent et que la déclaration de fonction soit unique
	// Les variables déclarées dans la fonction ne doivent pas être accessible depuis l'extérieur
	// (les détruires ou bien préciser à quel programme elles appartiennent)
	type()
	<FONCTION>
	<ident>		 {
			IdentArray.currentNameFunction = YakaTokenManager.identLu ;
			IdentArray.addGlobal(
				IdentArray.currentNameFunction,
				new IdFunction(IdentArray.lastType)
			);
			Yaka.Interpreter.label(IdentArray.currentNameFunction) ;
			}
	paramForms() 	{
			}
	bloc()
	<FFONCTION>	{
				IdentArray.sortParams(IdentArray.currentNameFunction) ;
				IdentArray.initOffsetParam() ;
				IdentArray.cleanLocaux() ;
				IdentArray.initOffsetVar() ;
			}
}

void paramForms() : {} {
	"("
		(
			paramForm()
			( "," paramForm() )*
		)?
	")"
}

void paramForm():{} {
	type() <ident> 		{
					IdentArray.shiftOffsetParam();
					IdentArray.addParam(IdentArray.currentNameFunction, YakaTokenManager.identLu, new IdVar(IdentArray.offsetParam,IdentArray.lastType)) ;
				}

}



/**
 * ====================================================
 * =================== Instructions ===================
 * ====================================================
 */

void suiteInstr() : {} {
	instruction()
	( ";" (instruction())? )*
}


void instruction() : {} {
	affectation() |
	lecture()|
	ecriture()|
	boucle()|
	conditionnel()|
	retourne()
}


// variable = (expression | variable | constante)
void affectation() : {} {
	(<ident>) {
				
		Ident affectId = IdentArray.getLocal(YakaTokenManager.identLu);
		try {
			if(affectId.isConst())
				throw new ParseException("Affectation impossible sur une constante");
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur d'affectation, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}

	}
	// Todo : fonction
	(<EGAL> (expression()/* | fonction()*/) ) {
		Yaka.Interpreter.affect(affectId);
	}
}


// LIRE(variable)
void lecture() : {} {
	// Todo : véririfier que la lecture ce fait sur une variable
	(<LIRE>"("<ident>")") {
		Yaka.Interpreter.lireEnt(IdentArray.getLocal(YakaTokenManager.identLu));
	}
}


// ECRIRE(chaine)
void ecriture() : {} {

	(<ECRIRE>"("

		(expression() {
			Yaka.Interpreter.ecrireEnt();
		}
		| <chaine> {
			Yaka.Interpreter.ecrireChaine(YakaTokenManager.chaineLue);
		})

	")")

	| (<ALALIGNE>) {
		Yaka.Interpreter.aLaLigne();
	}
}


// TANTQUE condition FAIRE
//     instructions
// FAIT
void boucle() : {} {
	{
		// Génération des étiquettes de saut avec incrémentation du numéro
		String faire = Condition.getLabel(tokenImage[FAIRE]);
		String fait = Condition.getLabel(tokenImage[FAIT]);
	}
	<TANTQUE> {
		// Ajout de l'étiquette de début de boucle
		Yaka.Interpreter.label(faire);
	}
	expression() {
		try {
			String type = Expression.popType();

			// Vérification du type (booléen) de l'expression
			if(type != tokenImage[BOOLEEN])
				throw new ParseException("Expression non booléenne ("+type+" trouvé)");

			// Si expression fausse, on sort de la boucle
			Yaka.Interpreter.iffaux(fait);
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur d'iteration, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}
	}
	<FAIRE>
	suiteInstr() {
		// Saut sur l'étiquette de début de boucle
		Yaka.Interpreter.jump(faire);
	}
	<FAIT> {
		// Ajout de l'étiquette de fin de boucle
		Yaka.Interpreter.label(fait);
	}
}


// SI condition ALORS
//     instructions
// SINON
//     instructions
// FSI
void conditionnel() : {} {
	{
		// Génération des étiquettes de saut avec incrémentation du numéro
		String sinon = Condition.getLabel(tokenImage[SINON]);
		String fsi = Condition.getLabel(tokenImage[FSI]);
	}
	<SI>
	expression() {
		try {
			String type = Expression.popType();

			// Vérification du type (booléen) de l'expression
			if(type != tokenImage[BOOLEEN])
				throw new ParseException("Expression non booléenne ("+type+" trouvé)");

			// Si expression fausse, on passe au bloc "sinon" de la conditionnel
			Yaka.Interpreter.iffaux(sinon);
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur de condition, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}
	}
	<ALORS>
	suiteInstr() {
		// Saut en fin de conditionnel (pour ne pas exécuter les instructions "sinon")
		Yaka.Interpreter.jump(fsi);

		// Ajout de l'étiquette du début de bloc "sinon" de la conditionnel
		Yaka.Interpreter.label(sinon);
	}
	(
		<SINON>
		suiteInstr()
	) ?
	<FSI> {
		// Ajout de l'étiquette de fin de conditionnel
		Yaka.Interpreter.label(fsi);
	}
}


// variable = fonction(variable, variable, ...)
void retourne() : {} {

	// Todo : faire l'affection de la valeur de retour (et vérifier son type) de la fonction
	//(<ident> <EGAL>)?

	// Todo : vérifier que la fonction appelé existe
	// et que le bon nombre de paramètres (chacun avec le bon type) est passé
	<RETOURNE> expression() 	{
						Yaka.Interpreter.retourne(IdentArray.getGlobal(IdentArray.currentNameFunction).nbParams() + 4);
					}
}






/**
 * ===================================================
 * =================== Expressions ===================
 * ===================================================
 */

void expression() : {} {

	simpleExpr()
	(
		opRel()
		simpleExpr() {

			String type1 = Expression.popType();
			String operator = Expression.popOperator();
			String type2 = Expression.popType();

			try {

				String newType = Expression.dualOperandType(type1, operator, type2);

				if(newType == tokenImage[ERROR] && type1 != tokenImage[ERROR] && type2 != tokenImage[ERROR])
					throw new ParseException("Operation de type "+type1+" "+operator+" "+type2+" interdite");

				else {
					Expression.addType(newType);

					if (operator == tokenImage[INF])
						Yaka.Interpreter.iinf();

					else if (operator == tokenImage[INFEGAL])
						Yaka.Interpreter.iinfegal();

					else if (operator == tokenImage[SUP])
						Yaka.Interpreter.isup();

					else if (operator == tokenImage[SUPEGAL])
						Yaka.Interpreter.isupegal();

					else if (operator == tokenImage[EGAL])
						Yaka.Interpreter.iegal();

					else if (operator == tokenImage[DIFF])
						Yaka.Interpreter.idiff();

					else
						throw new ParseException("Operateur "+operator+" inattendu");
				}
			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}
	)?

}


void simpleExpr() : {} {

	terme()
	(
		opAdd()
		terme() {

			String type1 = Expression.popType();
			String operator = Expression.popOperator();
			String type2 = Expression.popType();

			try {

				String newType = Expression.dualOperandType(type1, operator, type2);

				if(newType == tokenImage[ERROR] && type1 != tokenImage[ERROR] && type2 != tokenImage[ERROR])
					throw new ParseException("Operation de type "+type1+" "+operator+" "+type2+" interdite");

				else {
					Expression.addType(newType);

					if(operator == tokenImage[PLUS])
						Yaka.Interpreter.iadd();

					else if (operator == tokenImage[MOINS])
						Yaka.Interpreter.isub();

					else if (operator == tokenImage[OU])
						Yaka.Interpreter.ior();

					else
						throw new ParseException("Operateur "+operator+" innatendu");
				}
			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}
	)*

}


void terme() : {} {

	facteur()
	(
		opMul()
		facteur() {

			String type1 = Expression.popType();
			String operator = Expression.popOperator();
			String type2 = Expression.popType();

			try {

				String newType = Expression.dualOperandType(type1, operator, type2);

				if(newType == tokenImage[ERROR] && type1 != tokenImage[ERROR] && type2 != tokenImage[ERROR])
					throw new ParseException("Operation de type "+type1+" "+operator+" "+type2+" interdite");

				else {
					Expression.addType(newType);

					if (operator == tokenImage[MUL])
						Yaka.Interpreter.imul();

					else if (operator == tokenImage[DIV])
						Yaka.Interpreter.idiv();

					else if(operator == tokenImage[ET])
						Yaka.Interpreter.iand();

					else
						throw new ParseException("Operateur "+operator+" innatendu");
				}
			}
			catch(ParseException e) {
				err = true;
				TokenMgrError error = new TokenMgrError(
					"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
					TokenMgrError.LEXICAL_ERROR
				);
				Writer.errorln(error.getMessage());
			}
		}
	)*

}

void facteur() : {} {

	primaire()
	| opNeg() primaire() {

		String type = Expression.popType();
		String operator = Expression.popOperator();

		try {

			String newType = Expression.singleOperandType(operator, type);

			if(newType == tokenImage[ERROR] && type != tokenImage[ERROR])
					throw new ParseException("Operation de type "+operator+" "+type+" interdite");

			else {
				Expression.addType(newType);

				if(operator == tokenImage[MOINS])
					Yaka.Interpreter.ineg();

				else if(operator == tokenImage[NON])
					Yaka.Interpreter.inot();

				else
					throw new ParseException("Operateur "+operator+" innatendu");
			}
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur d'expression, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}
	}
}


void primaire() : {} {
	valeur()
	| "(" expression() ")"
}


void valeur() : {} {
	(<entier> {
		Expression.addType(tokenImage[ENTIER]);
		Yaka.Interpreter.iconst(YakaTokenManager.entierLu);
	}

	| (<ident>  {
		try {
			
			Ident id = IdentArray.getLocal(YakaTokenManager.identLu) ;
			if (id == null)
				id = IdentArray.getGlobal(IdentArray.currentNameFunction).getParam(YakaTokenManager.identLu) ;
			if (id == null) {
				id = IdentArray.getGlobal(YakaTokenManager.identLu) ;
				if (id != null)
					IdentArray.currentNameFunction = YakaTokenManager.identLu ;
			}
			
			if(id == null){
				
				Expression.addType(YakaConstants.tokenImage[YakaConstants.ERROR]);
				throw new ParseException("Identifiant \""+YakaTokenManager.identLu+"\" non declare");
			}

			Expression.addType(id.type);

			if(id.isVar())
				Yaka.Interpreter.iload(id.getValue());

			else {
				if(id.isConst())
					Yaka.Interpreter.iconst(id.getValue());
				else
					if (id.isFunction()) {
						Yaka.Interpreter.reserveRetour() ;
					}
			}
		}
		catch(ParseException e) {
			err = true;
			TokenMgrError error = new TokenMgrError(
				"Erreur lexicale, ligne "+YakaTokenManager.currentLine+" :\n"+e.getMessage()+"\n",
				TokenMgrError.LEXICAL_ERROR
			);
			Writer.errorln(error.getMessage());
		}
	}
	(argumentsFonction())?) {
				Yaka.Interpreter.call(IdentArray.currentNameFunction);
				}

	| <VRAI> 	{
		Expression.addType(tokenImage[BOOLEEN]);
		Yaka.Interpreter.iconst(Yaka.Interpreter.TRUE);
	}

	| <FAUX> 	{
		Expression.addType(tokenImage[BOOLEEN]);
		Yaka.Interpreter.iconst(Yaka.Interpreter.FALSE);
	})

}


void opRel() : {} {
	<EGAL> {
		Expression.addOperator(tokenImage[EGAL]);
	}

	| <DIFF> {
		Expression.addOperator(tokenImage[DIFF]);
	}

	| <INF>	{
		Expression.addOperator(tokenImage[INF]);
	}

	| <INFEGAL>	{
		Expression.addOperator(tokenImage[INFEGAL]);
	}

	| <SUP> {
		Expression.addOperator(tokenImage[SUP]);
	}

	| <SUPEGAL>	{
		Expression.addOperator(tokenImage[SUPEGAL]);
	}
}


void opAdd() : {} {
	<PLUS> {
		Expression.addOperator(tokenImage[PLUS]);
	}

	| <MOINS> {
		Expression.addOperator(tokenImage[MOINS]);
	}

	| <OU> {
		Expression.addOperator(tokenImage[OU]);
	}
}


void opMul() : {} {
	<MUL> {
		Expression.addOperator(tokenImage[MUL]);
	}

	| <DIV> {
		Expression.addOperator(tokenImage[DIV]);
	}

	| <ET> {
		Expression.addOperator(tokenImage[ET]);
	}
}


void opNeg() : {} {
	<MOINS> {
		Expression.addOperator(tokenImage[MOINS]);
	}

	| <NON> {
		Expression.addOperator(tokenImage[NON]);
	}
}

void argumentsFonction(): {} {
	"(" (expression() (","expression())* )? ")" 	
}


